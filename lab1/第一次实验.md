<h1 align="center"> Lab1: 比麻雀更小的麻雀 </h1>

## 实验目的

实验1主要讲解最小可执行内核和启动流程。我们的内核主要在 Qemu 模拟器上运行，它可以模拟一台 64 位 RISC-V 计算机。为了让我们的内核能够正确对接到 Qemu 模拟器上，需要了解 Qemu 模拟器的启动流程，还需要一些程序内存布局和编译流程（特别是链接）相关知识。

本章你将学到：

使用 链接脚本 描述内存布局。

进行 交叉编译 生成可执行文件，进而生成内核镜像。

使用 OpenSBI 作为 bootloader 加载内核镜像，并使用 Qemu 进行模拟。

使用 OpenSBI 提供的服务，在屏幕上格式化打印字符串用于以后调试。

## 实验内容：

实验1主要讲解最小可执行内核和启动流程。我们的内核主要在 Qemu 模拟器上运行，它可以模拟一台 64 位 RISC-V 计算机。为了让我们的内核能够正确对接到 Qemu 模拟器上，需要了解 Qemu 模拟器的启动流程，还需要一些程序内存布局和编译流程（特别是链接）相关知识,以及通过opensbi固件来通过服务。

## 练习1：理解内核启动中的程序入口操作

### 实验要求
阅读 kern/init/entry.S内容代码，结合操作系统内核启动流程，说明指令 la sp, bootstacktop 完成了什么操作，目的是什么？ tail kern_init 完成了什么操作，目的是什么？

### 实验过程
kern/init/entry.S是一段RISC-V汇编代码，如下为对其代码的阅读分析：

    #include <mmu.h>
    #include <memlayout.h>
以上代码用于包含头文件。mmu.h定义了与内存管理单元（MMU）相关的常量，例如页表项的标志位、页大小等，memlayout.h头文件通常定义了内存布局的常量，例如内核起始地址、设备地址、栈地址等。

        .section .text,"ax",%progbits
.section是指令，告诉汇编器接下来的内容属于哪个段。

.text段表明是只读的可执行代码段。

"ax"是个标志，"a"代表该段在程序加载时需要被分配到内存中,"x"表示该段包含可执行指令。

%progbits 是段类型，即“程序定义内容”，即这个段中存放的是程序自己定义的代码或数据。

        .globl kern_entry
声明符号kern_entry为全局符号，使链接器与其它目标文件可见，并可作为 ELF 的入口点。

    kern_entry:
标签kern_entry，表示内核入口的地址。系统启动后会把控制权交到这里。

        la sp, bootstacktop
la = "load address"，顾名思义，用于加载地址。它把标签 bootstacktop 代表的地址加载到栈指针sp里，sp寄存器指向当前函数调用栈的顶部。

这句话的效果就是将堆栈指针初始化为 bootstacktop，也就是把栈指向预分配栈区域的最高地址。后继的代码会按照调用约定使用 sp，所以需要先建立一个安全可用的内核栈。


        tail kern_init
tail 是一个尾调用的伪指令：它会把控制权转移到 kern_init，并且不会保存返回地址，也就是不会再返回到 kern_entry。它会实现直接无返回地跳到kern_init，把 kern_entry 的栈帧“替换”为 kern_init 的执行环境。

    .section .data
切换到 .data 段，后面定义的数据会被放在可写数据段中。

        # .align 2^12
这是个注释，写明是按 2^12 对齐（4096 字节，即一页）。
        .align PGSHIFT
.align PGSHIFT 使用宏 PGSHIFT（通常定义为 12）来做对齐；.align N 一般按 2^N 字节对齐，因此 .align 12就是按照4096字节对齐）。

        .global bootstack
声明全局符号bootstack，表示栈底。

    bootstack:
        .space KSTACKSIZE

在汇编输出中预留 KSTACKSIZE个 字节（全为零），用于作为内核的初始栈空间。KSTACKSIZE 源自 memlayout.h 的宏定义，我查看后发现是2*4096个字节，即2个页。

        .global bootstacktop
    bootstacktop:

定义 bootstacktop 标签，通常放在栈空间的末尾（高地址）。la sp, bootstacktop 正是把 sp 设置为这里。

bootstacktop 没有紧随数据后面的空间指令，因为它就是栈空间的结束位置标签。

### 解答
内核启动的总体流程大体如下：

加电复位 → CPU从0x1000进入MROM → 跳转到0x80000000(OpenSBI) → OpenSBI初始化并加载内核到0x80200000 → 跳转到entry.S → 调用kern_init() → 输出信息 → 结束


我们都知道c代码运行中栈的重要性，所以，内核启动必须实现给 CPU 一个安全的栈，让 C 函数能正常执行。

指令 la sp, bootstacktop 实现了初始化内核的栈指针寄存器，目的是为后续的函数调用和局部变量分配提供合法的栈空间。结合上边的代码阅读，我可以知道系统为这个栈分配了两个页的空间大小，所以这个代码实现了让 CPU 从这块 8KB 的内存最高处开始作为栈，逐渐向下使用。

tail kern_init实现了无条件跳转到函数kern_init，并且不再返回。也就是永久的把cpu控制权转移给kern_init。在启动汇编（kern_entry）阶段，我们只能执行非常简单的汇编指令，做少量硬件初始化。复杂的操作（比如内存检测、页表建立、中断初始化、设备注册等）都必须用C来完成。这个代码的目的就是结束kern_entry阶段，把控制权交给 C 语言内核。而 kern_init() 就是整个 C 内核的入口函数。

总而言之， kern/init/entry.S的作用就是为CPU分配安全的栈空间，然后跳转到用C语言实现的内核里。

## 练习2: 使用GDB验证启动流程

### 实验要求

为了熟悉使用 QEMU 和 GDB 的调试方法，请使用 GDB 跟踪 QEMU 模拟的 RISC-V 从加电开始，直到执行内核第一条指令（跳转到 0x80200000）的整个过程。通过调试，请思考并回答：RISC-V 硬件加电后最初执行的几条指令位于什么地址？它们主要完成了哪些功能？请在报告中简要记录你的调试过程、观察结果和问题的答案。

tips:

启动流程可以分为以下几个阶段：

1) CPU 从复位地址（0x1000）开始执行初始化固件（OpenSBI）的汇编代码，进行最基础的硬件初始化。

2) SBI 固件进行主初始化，其核心任务之一是将内核加载到 0x80200000。可以使用watch *0x80200000观察内核加载瞬间，避免单步跟踪大量代码。

3) SBI 最后跳转到 0x80200000，将控制权移交内核。使用 b *0x80200000 可在此中断，验证内核开始执行



### 实验过程
通常，RISC-V硬件加电后，会从某个特定的地址开始执行指令。这个地址通常是0x1000或0x80000000，具体取决于硬件设计。在QEMU模拟发设备上，是从0x1000开始的。

我们首先需要启动QEMU，并让它暂停在初始状态，等待GDB连接。这样我们就可以通过GDB来跟踪CPU从加电开始执行的每一条指令。

我们首先在一个终端中用make debug启动QEMU等待GDB连接。
<p align="center">
  <img src="picture/pic1.png" alt="figure">
</p>

然后在另一个窗口输入make gdb，这个命令其实是一系列操作的集合：

file bin/kernel：让GDB加载我们编译好的内核文件，这个文件里包含宝贵的调试符号（函数名、变量名等）。

set arch riscv:rv64：告诉GDB，我们要调试的是RISC-V 64位的程序。

target remote localhost:1234：让GDB去连接本机（localhost）的1234端口，也就是QEMU正在等待我们的地方。

如下图，GDB 已成功连接到 QEMU，CPU 停在 0x1000 地址，现在可以开始单步调试系统启动过程。
<p align="center">
  <img src="picture/pic2.png" alt="figure">
</p>

根据任务要求，我们可以使用GDB命令x/10i $pc来查看当前程序计数器（PC）指向的地址以及后续的10条指令，得到结果如下(因为在0x1010处实现了跳转，所以只展示执行的5条指令)：

    0x1000:	auipc	t0,0x0 //将当前PC的高20位与0x0左移12位相加，然后存入t0。所以t0 = PC + 0 = 0x1000。
    0x1004:	addi	a1,t0,32//将t0加上32（0x20）存入a1，所以a1 = 0x1000 + 32 = 0x1020。
    0x1008:	csrr	a0,mhartid//读取当前硬件线程ID（mhartid）到a0。
    0x100c:	ld	t0,24(t0)//从内存地址t0+24（0x1018）处加载一个双字（64位）到t0。我们需要查看0x1018地址处存储的值是什么，因为这里将根据这个值进行跳转。
    0x1010:	jr	t0//跳转到t0寄存器指定的地址。
接下来使用si进行单步调试，并查看相关寄存器的内容：
<p align="center">
  <img src="picture/pic3.png" alt="figure">
</p>
可以看见，0x1000处的代码执行后，t0处存入0x1000，其目的是获取当前代码位置的基地址。0x1004处的代码执行后，a1处存入0x1020，0x1008处的代码执行后，a0处存入0x0，说明当前执行的硬件线程 ID 为 0。0x100c处的代码执行后，t0处存了0x80000000，0x1010处的代码执行后，可以看见，pc跳转到了0x80000000。事实上我们可以知道0x80000000开始的代码是作为bootloader的OpenSBI.bin。 

接下来继续使用GDB命令x/30i $pc来查看0x80000000地址以及后续的30条指令。
<p align="center">
  <img src="picture/pic4.png" alt="figure">
</p>

可以看见大量的汇编代码，这里不进行一一解释了。

关于内核的加载，我注意到，makefile里直接把内核加载到了 0x80200000，这绕过了SBI的加载过程。如下图，可以看见，程序停在 0x1000（SBI 启动代码）时，内核代码就已经加载到内存里，SBI 启动后直接跳转到内核。

<p align="center">
  <img src="picture/pic5.png" alt="figure">
</p>

链接脚本指定了内核的入口地址。我们可以直接在这个地址上打断点，但更简单的方法是使用函数名。因为编译器帮我们把函数名和地址对应了起来（调试符号），所以我们可以直接对kern_entry函数下断点，随后执行continue(缩写为c)开始执行程序，内核会在运行到我们设置好的断点处停止：

<p align="center">
  <img src="picture/pic6.png" alt="figure">
</p>

可以看见，程序运行到0x80200000处停下了，这也是内核的入口，对应的指令是之前解释过的 la sp, bootstacktop，开始分配栈空间。

<p align="center">
  <img src="picture/pic7.png" alt="figure">
</p>
查看后续指令，和我们分析的一样，分配完栈后，就把cpu控制权转移给了c语言写的kern_init。

然后看左边窗口的debug输出，说明SBI已经成功初始化：
<p align="center">
  <img src="picture/pic9.png" alt="figure">
</p>
然后我们可以用disassemble kern_init 查看kern_init的反汇编代码，可以看见它的最后一个指令是跳转到自己本身，所以最后无限循环了。

<p align="center">
  <img src="picture/pic8.png" alt="figure">
</p>

我们使用c指令，继续执行，可以看见左边的debug输出了(THU.CST) os is loading ...，右边调试器进入死循环，和我们分析的一致。

<p align="center">
  <img src="picture/pic10.png" alt="figure">
</p>
<p align="center">
  <img src="picture/pic11.png" alt="figure">
</p>

### 解答
1.RISC-V 硬件加电后最初执行的几条指令位于0x1000到0x1010。

2.具体作用如下：

0x1000:	auipc	t0,0x0 //将当前PC的高20位与0x0左移12位相加，然后存入t0。所以t0 = PC + 0 = 0x1000。

0x1004:	addi	a1,t0,32//将t0加上32（0x20）存入a1，所以a1 = 0x1000 + 32 = 0x1020。

0x1008:	csrr	a0,mhartid//读取当前硬件线程ID（mhartid）到a0。

0x100c:	ld	t0,24(t0)//从内存地址t0+24（0x1018）处加载一个双字（64位）到t0。我们需要查看0x1018地址处存储的值是什么，因为这里将根据这个值进行跳转。

0x1010:	jr	t0//跳转到t0寄存器指定的地址。

## 重要知识点对应
### Minix架构（层次式的设计示例）
在课件中提到了Minix架构，Minix 是一个经典的微内核操作系统，以其层次式设计而闻名，我们本次实验使用的ucore内核受到了 Minix 的很大影响，不过它们之间也有很多不同。

我们通常将操作系统内核分为宏内核和微内核两种设计架构。它们的主要区别在于内核的功能划分和运行模式。

宏内核将操作系统的主要功能模块（如进程管理、内存管理、文件系统、设备驱动等）都运行在内核态，同一个地址空间中。这些模块之间通过函数调用直接通信。

微内核的设计思想是尽可能减少内核的功能，只将最核心的功能（如进程调度、进程间通信、内存管理）放在内核中，而其他功能（如文件系统、设备驱动）作为用户态服务运行。这些服务之间通过消息传递进行通信。我们本次实验的ucore内核就是一个宏内核。
<p align="center">
  <img src="picture/pic12.png" alt="figure">
</p>
如上图是微内核minix的架构层，第一层内核层是最高特权级，它运行在内核态，直接与硬件交互，只包含无法在用户态实现的功能。如果某个功能能在用户态实现，就绝不放在内核中。

第二层I/O 任务层是次高特权级，这一层包含所有的设备驱动程序，每个驱动程序都作为独立的用户进程运行。包括磁盘任务，终端任务，系统任务等，它们虽然运行在用户态，但这些进程被授予访问特定硬件设备的权限。

第三层是服务层，具有中等特权，这一层包含主要的系统服务进程，为上层应用程序提供高级操作系统服务。它们通过接收下层I/O任务的消息和上层用户进程的请求，协调完成复杂的系统功能。

第四层用户应用程序层包含所有普通的用户应用程序。

而我们的ucore宏内核则与之不同，其所有服务在内核态，根据实验指导书所说，riscv有四个特权级（有一个目前未使用），ucore内核建立在riscv上，使用了其中的三个特权级：U（用户态）、S（内核态）和M（机器态，由OpenSBI固件使用）。  
<p align="center">
  <img src="picture/pic13.png" alt="figure">
</p>

OpenSBI固件使用M级，为ucore提供运行环境。
ucore内核运行在S模式，负责管理整个系统。
用户程序运行在U模式，受到内核的监控和管理。


### OpenSBI固件
Bootloader是在操作系统运行前执行的小型程序，负责将操作系统从存储设备加载到内存，并完成控制权的转移。

即实现：

    加电 → Bootloader执行 → 加载OS到内存 → 跳转到OS → OS开始运行


在本次实验的QEMU模拟的riscv计算机里，我们使用QEMU自带的bootloader: OpenSBI固件，那么在 Qemu 开始执行任何指令之前，首先要将作为 bootloader 的 OpenSBI.bin 加载到物理内存以物理地址 0x80000000 开头的区域上，然后将操作系统内核加载到QEMU模拟的硬盘中。

### 加载

在现有的ucore中，操作系统的加载实际上是由QEMU来完成，在Qemu开始执行任何指令之前，首先两个文件将被加载到Qemu的物理内存中：即作为bootloader的 OpenSBI.bin被加载到物理内存以物理地址 0x80000000 开头的区域上，同时内核镜像os.bin被加载到以物理地址 0x80200000 开头的区域上。

在上边的实验里我们也进行了验证，在程序停在 0x1000（SBI 启动代码）时，内核代码就已经加载到内存0x80200000里。

### 内存布局
内存布局，也就是指各个段所放的位置，一种常见内存布局如下：
<p align="center">
  <img src="picture/pic14.png" alt="figure">
</p>

在我们本次实验使用的链接脚本中，指定了内核在内存中的布局，包括各个段（section）的位置和顺序。

我们指定输出架构为riscv，入口点为kern_entry，这意味着程序从kern_entry符号开始执行。然后，我们定义了一个基地址BASE_ADDRESS为0x80200000，这是内核被加载到内存中的地址。

在SECTIONS命令中，我们定义了各个段的放置位置：

.text段：从BASE_ADDRESS开始，首先放置kern_entry的代码（确保入口点在开头），然后放置其他所有代码段。

.rodata段：只读数据段，存放常量等。

.data段：已初始化的全局变量等。在.data段之前，我们进行了0x1000（4KB）的对齐，这是因为内存管理通常以页为单位，4KB是常见的页大小。

.sdata段：小数据段，用于存放小数据，例如char、short等，这些数据可以通过相对地址快速访问。

.bss段：未初始化的全局变量，在程序加载时会被初始化为0。

这个链接脚本的作用是确保内核的各个部分被放置在内存中正确的位置，并且入口点位于预期的地址（0x80200000），这样当bootloader将内核加载到内存后，跳转到0x80200000就能执行kern_entry的代码。

这个脚本的内存布局虽然和上述的不完全一样，但大体上是一致的。它的栈分配在kern_entry，即.text部分。
关系：实验的内存布局是原理中物理内存布局在 kernel 初始化阶段的具体体现，为后续内存管理奠定基础。
差异：实验聚焦于内核自身加载和运行所需的内存布局；原理则涵盖整个系统的内存划分，包括进程内存空间等更广泛内容。
## 未涉及到的知识点

### 进程管理与调度
进程管理与调度确实是操作系统最核心的功能之一，但在本次实验中没有涉及。我们本次实验只有一个内核线程，没有其他进程，因此没有涉及到调度管理的一些问题。

### 虚拟内存管理
虚拟内存是操作系统为每个进程提供的虚拟内存空间，它使得每个进程都拥有独立的地址空间，从而隔离不同进程的内存访问。但是本次实验比较简单，我们主要关注的是Bootloader如何工作，如何加载内核等，没有引入更加复杂的虚拟内存管理。

### I/O系统
严格来说，I/O系统在这里已经有所涉及，但只是非常初步的利用现有固件服务进行输出，还没有涉及到直接操作硬件设备的驱动程序开发。
在kern_init函数中，我们看到了cprintf函数，它用于输出字符串。在ucore中，cprintf最终会调用控制台输出函数，这个控制台输出是通过RISC-V的SBI调用实现的，即通过ecall指令请求M模式的OpenSBI来帮助完成I/O操作。

我们没有涉及更完整的I/O系统，例如：直接驱动控制台设备进行输入输出，实现文件系统（存储设备I/O）等。


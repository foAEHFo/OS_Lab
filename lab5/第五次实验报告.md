<h1 align="center"> lab3：断,都可以断 </h1>

 <div align="center">

张德民 刘越帅 欧广元

</div>

## 实验目的

1. 了解第一个用户进程创建过程
2. 了解系统调用框架的实现机制
3. 了解ucore如何实现系统调用sys_fork/sys_exec/sys_exit/sys_wait来进行进程管理

## 实验内容
实验4完成了内核线程，但到目前为止，所有的运行都在内核态执行。实验5将创建用户进程，让用户进程在用户态执行，且在需要ucore支持时，可通过系统调用来让ucore提供服务。为此需要构造出第一个用户进程，并通过系统调用sys_fork/sys_exec/sys_exit/sys_wait来支持运行不同的应用程序，完成对用户进程的执行过程的基本管理。

## 实验过程

### 练习0 填写已有实验

本实验依赖实验2/3/4。请把你做的实验2/3/4的代码填入本实验中代码中有“LAB2”/“LAB3”/“LAB4”的注释相应部分。注意：为了能够正确执行lab5的测试应用程序，可能需对已完成的实验2/3/4的代码进行进一步改进。

### 练习1: 加载应用程序并执行（需要编码）

do_execv函数调用load_icode（位于kern/process/proc.c中）来加载并解析一个处于内存中的ELF执行文件格式的应用程序。你需要补充load_icode的第6步，建立相应的用户内存空间来放置应用程序的代码段、数据段等，且要设置好proc_struct结构中的成员变量trapframe中的内容，确保在执行此进程后，能够从应用程序设定的起始执行地址开始执行。需设置正确的trapframe内容。

#### 请在实验报告中简要说明你的设计实现过程。

    /* 将用户栈指针设置为用户栈顶（USTACKTOP） */
        tf->gpr.sp = USTACKTOP;

        /* 从 ELF 头获取程序入口地址并设置 sepc/epc */
        tf->epc = elf->e_entry;

        /* 构造返回到用户态时的 sstatus：
        * - 清除 SPP，使 sret 返回到用户态（U-mode）；
        * - 置位 SPIE，使 sret 后中断按 SPIE 的值恢复；
        * - 清除 SIE（在内核中禁用中断，等待 sret 由 SPIE 恢复）；
        * 同时尽量保留原有 sstatus 的其它位（如 SUM），以免破坏访问策略。
        */
        uintptr_t newsstatus = (sstatus & ~SSTATUS_SPP) | SSTATUS_SPIE;
        newsstatus &= ~SSTATUS_SIE;
        tf->status = newsstatus;

如上边的代码，就是我补充的第六步，主要是按照注释进行编写代码。

首先tf->gpr.sp是用户栈指针，应该设置为用户栈顶 所以设置为USTACKTOP，tf->epc是程序入口地址，所以设置为 ELF 头中的 e_entry。

tf->status是进程状态寄存器sstatus，应该设置为适合用户程序运行的值，首先拿用户态原本的 sstatus，然后把SSTATUS_SPP置零，说明这个进程应该去往用户态运行，以后执行sret时，返回到用户态。

然后把SSTATUS_SPIE置1，sret后用户态恢复“中断开启”。

最后SSTATUS_SIE置为0，表明在内核态不希望发生中断。

#### 请简要描述这个用户态进程被ucore选择占用CPU执行（RUNNING态）到具体执行应用程序第一条指令的整个经过。

kern_init 执行完 proc_init 后，会调用 cpu_idle()。在 cpu_idle() 中，有一个 while (1) 循环，由于 idleproc->need_resched = 1，循环会立即调用 schedule()。schedule() 会从就绪队列中选择下一个进程（也就是我们的用户进程），然后通过 proc_run() 切换到它。此时，current变为initproc，开始执行init_main函数。

在proc_run()中，首先禁用中断，保存当前进程指针，然后切换页表，切换上下文，最后打开中断，但是切换完成后，CPU在新进程的上下文中执行，但仍在内核态。

新进程恢复后，从forkret函数开始执行（这是switch_to恢复的返回地址，由copy_thread设置）。

forkret 调用 forkrets(current->tf)。

    .globl forkrets
    forkrets:
        # set stack to this new process's trapframe
        move sp, a0
        j __trapret


这是一个汇编函数，将栈指针sp设置为当前进程的 trapframe 地址（move sp, a0），然后跳转到 __trapret。

    .globl __trapret
    __trapret:
        RESTORE_ALL
        # return from supervisor call
        sret
 

__trapret 调用 RESTORE_ALL 宏，从 trapframe 中恢复所有寄存器，包括通用寄存器 (x0-x31)、状态寄存器 (sstatus)、异常程序计数器 (sepc/epc) 等。关键是恢复我的代码设置的值，tf->gpr.sp = USTACKTOP：栈指针恢复为用户栈顶。tf->epc = elf->e_entry：程序计数器恢复为应用程序入口地址（ELF 文件的 e_entry）。tf->status = newsstatus：状态寄存器恢复为用户态设置（清除 SPP 位，使 SPP=0 表示用户态；置位 SPIE，使中断在用户态启用；清除 SIE，在内核态禁用中断）。

这是在load_icode函数中设置的，也就是我刚刚实现的第六步，load_icode函数在proc.c的do_execve函数中被调用，do_execve函数在 syscall.c 的 sys_exec 函数中被调用，sys_exec系统调用主要在内核启动用户程序时使用，用于加载和执行新的用户程序映像，

在 proc.c 的 user_main 函数中，通过 KERNEL_EXECVE 宏调用 sys_exec，来执行用户程序。也就是说，最后sret就会返回用户空间，并开始执行用户进程。栈指针 sp 现在指向用户栈顶 (USTACKTOP)，用户程序可以使用它。此时，进程正式进入用户态，CPU 开始执行应用程序的第一条指令（位于 elf->e_entry）。

从 elf->e_entry 开始，用户程序在用户态运行，访问用户空间内存。如果需要内核服务（如系统调用），会触发陷阱 (ecall)，进入内核态处理后，再通过 sret 返回用户态继续执行。

### 练习2: 父进程复制自己的内存空间给子进程（需要编码）

创建子进程的函数do_fork在执行中将拷贝当前进程（即父进程）的用户内存地址空间中的合法内容到新进程中（子进程），完成内存资源的复制。具体是通过copy_range函数（位于kern/mm/pmm.c中）实现的，请补充copy_range的实现，确保能够正确执行。

请在实验报告中简要说明你的设计实现过程。

如何设计实现Copy on Write机制？给出概要设计，鼓励给出详细设计。

    Copy-on-write（简称COW）的基本概念是指如果有多个使用者对一个资源A（比如内存块）进行读操作，则每个使用者只需获得一个指向同一个资源A的指针，就可以该资源了。若某使用者需要对这个资源A进行写操作，系统会对该资源进行拷贝操作，从而使得该“写操作”使用者获得一个该资源A的“私有”拷贝—资源B，可对资源B进行写操作。该“写操作”使用者对资源B的改变对于其他的使用者而言是不可见的，因为其他使用者看到的还是资源A。

### 练习3: 阅读分析源代码，理解进程执行 fork/exec/wait/exit 的实现，以及系统调用的实现（不需要编码）

请在实验报告中简要说明你对 fork/exec/wait/exit函数的分析。并回答如下问题：

请分析fork/exec/wait/exit的执行流程。重点关注哪些操作是在用户态完成，哪些是在内核态完成？内核态与用户态程序是如何交错执行的？内核态执行结果是如何返回给用户程序的？

请给出ucore中一个用户态进程的执行状态生命周期图（包执行状态，执行状态之间的变换关系，以及产生变换的事件或函数调用）。（字符方式画即可）

执行：make grade。如果所显示的应用程序检测都输出ok，则基本正确。（使用的是qemu-1.0.1）

### 扩展练习 Challenge

1. 实现 Copy on Write （COW）机制

给出实现源码,测试用例和设计报告（包括在cow情况下的各种状态转换（类似有限状态自动机）的说明）。

这个扩展练习涉及到本实验和上一个实验“虚拟内存管理”。在ucore操作系统中，当一个用户父进程创建自己的子进程时，父进程会把其申请的用户空间设置为只读，子进程可共享父进程占用的用户内存空间中的页面（这就是一个共享的资源）。当其中任何一个进程修改此用户内存空间中的某页面时，ucore会通过page fault异常获知该操作，并完成拷贝内存页面，使得两个进程都有各自的内存页面。这样一个进程所做的修改不会被另外一个进程可见了。请在ucore中实现这样的COW机制。

由于COW实现比较复杂，容易引入bug，请参考 https://dirtycow.ninja/ 看看能否在ucore的COW实现中模拟这个错误和解决方案。需要有解释。

这是一个big challenge.

2. 说明该用户程序是何时被预先加载到内存中的？与我们常用操作系统的加载有何区别，原因是什么？





## 列出你认为本实验中重要的知识点，以及与对应的OS原理中的知识点，并简要说明你对二者的含义，关系，差异等方面的理解（也可能出现实验中的知识点没有对应的原理知识点）


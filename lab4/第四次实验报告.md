<h1 align="center"> lab4：进程管理 </h1>

张德民 刘越帅 欧广元

## 实验目的

- 了解虚拟内存管理的基本结构，掌握虚拟内存的组织与管理方式
- 了解内核线程创建/执行的管理过程
- 了解内核线程的切换和基本调度过程

## 实验内容

在前面的实验中，我们已经完成了物理内存管理和基础页表机制的实现，使内核具备了对物理内存页的分配与管理能力，并能够建立起虚拟地址到物理地址的基本映射结构。但当前系统仍然只能以单一执行流的方式运行，无法并发执行多个任务，也尚未体现虚拟内存机制在进程或线程隔离中的作用。

本实验将在此基础上进一步扩展，完成以下两方面内容：

首先，**进一步完善虚拟内存管理，实现基本的地址空间结构**。通过引入虚拟内存描述结构，管理进程或线程的虚拟地址空间布局，为每个执行实体提供逻辑上的运行空间。与后续实验中的缺页异常和页面置换不同，本实验中的虚拟内存仍采用**预映射方式**，即在建立地址空间时一次性完成所有需要的页表映射，不涉及按需分配或页面置换。

其次，**引入内核线程机制，实现多执行流并发运行能力**。内核线程是一种特殊形式的“进程”。当一个程序加载到内存中运行时，首先通过ucore OS的内存管理子系统分配合适的空间，然后就需要考虑如何分时使用CPU来“并发”执行多个程序，让每个运行的程序（这里用线程或进程表示）“感到”它们各自拥有“自己”的CPU。本实验将实现线程控制块、上下文切换和调度器等内容，从而实现多线程并发执行，使内核能够调度多个执行实体轮流使用 CPU 运行。

内核线程与用户进程的区别如下：

| 比较项   | 内核线程         | 用户进程                   |
| -------- | ---------------- | -------------------------- |
| 运行模式 | 仅在内核态运行   | 在用户态和内核态之间切换   |
| 地址空间 | 共享内核地址空间 | 拥有独立的用户虚拟地址空间 |

通过本实验，系统将从“单一执行流的内核”发展为“支持多线程调度的内核”，并完成基本的虚拟内存环境框架搭建，为后续实现用户进程、系统调用、缺页异常处理和页面置换等功能奠定基础。

需要注意的是，在ucore的调度和执行管理中，**对线程和进程做了统一的处理**。且由于ucore内核中的所有内核线程共享一个内核地址空间和其他资源，所以这些内核线程从属于同一个唯一的内核进程，即ucore内核本身。

## 实验过程

### 练习0：填写已有实验

相关内容均已按照Lab2，Lab3的实验填写到了Lab4上，运行结果如下(此时还没有填写Lab4的其他练习，因此进程创建失败，这很正常)：

![image-20251113172521143](第四次实验报告.assets/image-20251113172521143.png)



### 练习1：分配并初始化一个进程控制块（需要编码）

我们补全的alloc_proc函数代码如下：

```c
static struct proc_struct *
alloc_proc(void)
{
    struct proc_struct *proc = kmalloc(sizeof(struct proc_struct));
    if (proc != NULL)
    {
        proc->state = PROC_UNINIT;
        proc->pid = -1;
        proc->runs = 0;
        proc->kstack = (uintptr_t)kmalloc(KSTACKSIZE);
        proc->need_resched = 0;
        proc->parent = NULL;
        proc->mm = NULL;
        memset(&proc->context, 0, sizeof(struct context));
        proc->tf = NULL;
        proc->pgdir = boot_pgdir_pa;
        proc->flags = 0;
        proc->name[0] = '\0';
    }
    return proc;
}
```

函数一开始会使用**kmalloc**函数来申请一块结构体**proc_struct**大小的内存块，这块内存块作为进程控制块，需要被正确的初始化才能够使用。接下来是对它每一个字段初始化值的原因：

* **state**：该值有四个枚举值，分别是PROC_UNINIT未初始化态，PROC_SLEEPING非运行态（可能是就绪态或者阻塞态），PROC_RUNNABLE运行态，PROC_ZOMBIE终止态，因为此时该进程刚刚被创建，所有值都还未设，因此它只能是未初始化态，不是PROC_SLEEPING，更不是PROC_RUNNABLE或PROC_ZOMBIE态。
* **pid**：首先，一个进程的PID值会由后续的**get_pid**函数指定，在初始化函数中我们不需要关心，因此问题就变成了初始化为-1还是0的问题。在ucore中，闲逛进程的PID已经被初始化为了0，0是一个真正的存在的进程，因此初始化不应是一个已经存在的进程的PID，所以这里初始化为-1。
* **runs**：这个字段指示的是该进程的运行次数，此时这个进程还在创建过程中，因此该值当然是0.
* **kstack**：该值是一个地址，指向为进程独立分配的内核栈空间，因此需要调用**kmalloc**函数来获取一块内存，至于大小，宏定义**KSTACKSIZE**已经规定了
* **need_resched**：该值用于指定进程是否需要被调度出CPU，0是不需要1是需要。由初始化的状态PROC_UNINIT可知，这个值显然要设置为0，一个没被创建好的进程不可能需要被调出CPU
* **parent**：该指针指向这个进程的父进程，这里要初始化为NULL，因为后续会有另外的函数来定义这个值，现在我们还一无所知。
* **mm**：内核线程共享内核地址空间，无需独立内存管理结构，如果是用户进程，那么会使用**copy_mm**函数去复制父进程的内存，当然本次实验还不涉及。
* **context**：进程上下文，在进程创建阶段，该进程还没有任何的上下文，因此全部清0即可，避免后续使用因随机值导致异常。
* **tf**：指向中断帧数据结构**trapframe**，用于保存中断或系统调用时的硬件状态，此时新进程处在初始化，未触发中断，因此该值肯定是NULL
* **pgdir**：页表基地址，因为内核线程共享内核页表，因为**boot_pgdir_pa**是启动时初始化的页表物理地址，内核线程直接使用全局页表，无需独立地址空间，因此直接赋值**boot_pgdir_pa**，后续**proc_init**函数检查内核进程控制块的pgdir值是否是**boot_pgdir_pa**也证明了这一点。
* **flags**：进程标志位。这里直接清0即可，后续有需求后续会进行相关设置。
* **name**：进程名。此时还未指定，因此直接初始化为空字符串。

#### 请说明proc_struct中`struct context context`和`struct trapframe *tf`成员变量含义和在本实验中的作用是啥？

* **struct context context**：这个成员变量保存了一个进程的运行上下文。什么是进程的运行上下文？简言之，一个进程在运行到某个状态时，很可能因为主动或被动的原因需要被CPU调出，此时这个进程若想下次调入CPU时还能正确运行，就必须保存当前该进程的运行状态，比如一些关键寄存器的值。

  数据结构context 包含了被调用者保存寄存器s0-s11，还包含了返回地址寄存器ra和栈地址寄存器sp，这些寄存器构成了一个进程运行的上下文。

  因此，context用于进程间的上下文切换，即当调度器决定切换到另一个进程时，保存当前进程的执行状态（主要是ra和sp等关键寄存器和被调用者保存寄存器，并不是所有寄存器），并用于后续恢复目标进程的状态。

* **struct trapframe *tf**：这个数据结构我们并不陌生，在Lab3探索中断和异常机制时我们曾频繁的接触它，这个数据结构保存了中断或系统调用发生时的硬件状态。在一个进程运行时，其不仅要主动或者被动的被调入调出CPU(也就是进程调度)，还可能会产生一些中断和异常行为，此时CPU会暂停当前执行进程手中的活，转而去执行相对应的处理程序，这个时候就需要**tf**来保存硬件状态，以供处理程序完成之后继续进程的执行。

  因此，tf用于处理中断和系统调用（或是触发异常）。当发生中断或系统调用时，硬件会保存部分状态到trapframe，然后进入内核态处理。处理完成后，通过`tf`恢复进程的执行环境。

  

### 练习2：为新创建的内核线程分配资源（需要编码）



### 练习3：编写proc_run 函数（需要编码）



### 扩展练习 Challenge：



## 列出你认为本实验中重要的知识点，以及与对应的OS原理中的知识点，并简要说明你对二者的含义，关系，差异等方面的理解（也可能出现实验中的知识点没有对应的原理知识点）


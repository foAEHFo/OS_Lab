<h1 align="center"> lab3：断,都可以断 </h1>

 <div align="center">

张德民 刘越帅 欧广元

</div>

## 实验目的
实验3主要讲解的是中断处理机制。操作系统是计算机系统的监管者，必须能对计算机系统状态的突发变化做出反应，这些系统状态可能是程序执行出现异常，或者是突发的外设请求。当计算机系统遇到突发情况时，不得不停止当前的正常工作，应急响应一下，这是需要操作系统来接管，并跳转到对应处理函数进行处理，处理结束后再回到原来的地方继续执行指令。这个过程就是中断处理过程。

本章你将学到：

riscv 的中断相关知识。

中断前后如何进行上下文环境的保存与恢复。

处理最简单的断点中断和时钟中断。

## 实验内容
实验3主要讲解的是中断处理机制。通过本章的学习，我们了解了 riscv 的中断处理机制、相关寄存器与指令。我们知道在中断前后需要恢复上下文环境，用一个名为中断帧（TrapFrame）的结构体存储了要保存的各寄存器，并用了很大篇幅解释如何通过精巧的汇编代码实现上下文环境保存与恢复机制。最终，我们通过处理断点和时钟中断验证了我们正确实现了中断机制。

## 实验过程

### 练习1：完善中断处理 （需要编程）

请编程完善trap.c中的中断处理函数trap，在对时钟中断进行处理的部分填写kern/trap/trap.c函数中处理时钟中断的部分，使操作系统每遇到100次时钟中断后，调用print_ticks子程序，向屏幕上打印一行文字”100 ticks”，在打印完10行后调用sbi.h中的shut_down()函数关机。

要求完成问题1提出的相关函数实现，提交改进后的源代码包（可以编译执行），并在实验报告中简要说明实现过程和定时器中断中断处理的流程。实现要求的部分代码后，运行整个系统，大约每1秒会输出一次”100 ticks”，输出10行。

#### 解答

首先我开始完善trap.c中的中断处理函数，一共有三处需要完善的，但是两处关于异常的代码我们在挑战三部分进行讲解，这里只看第一处：

<p align="center">
  <img src="figure/zdm_fig1.png" alt="figure">
</p>

首先我增加了一句`static int print_num = 0;`，定义了一个整形静态变量print_num，用来存储打印的次数。

然后看case 部分：

首先使用`clock_set_next_event();`设置下一次时钟中断。函数定义如下：

    void clock_set_next_event(void) 
    { 
        sbi_set_timer(get_cycles() + timebase); 
    }

这里又使用了一个函数sbi_set_timer(),可以找到其定义如下：

    void sbi_set_timer(unsigned long long stime_value) {
        sbi_call(SBI_SET_TIMER, stime_value, 0, 0);
    }

这个是RISC-V平台下操作定时器的底层封装函数。这个函数的作用是设置下一次定时器中断触发的时间。参数stime_value表示CPU计时器的目标周期数，当CPU的get_cycles()达到这个值时，会触发一次定时器中断（IRQ）。

函数内部调用了`sbi_call(SBI_SET_TIMER, stime_value, 0, 0);`,其中`sbi_call()`RISC-V 的SBI调用函数,即通过SBI请求硬件做一些底层操作，SBI_SET_TIMER这是一个宏，表示SBI功能号，告诉SBI固件要执行设置定时器的操作，这个值是5。

即我们想设置下一次定时器中断，于是调用`sbi_set_timer(stime_value)`，`sbi_set_timer`再调用底层的`sbi_call`，传递功能号`SBI_SET_TIMER`和目标时间`stime_value`。SBI固件接收到请求后，配置硬件定时器寄存器，在CPU的计时器到达stime_value时发中断给操作系统。

这时我们再看`clock_set_next_event()`就可以理解它的作用了，用get_cycles()获取当前的cpu周期，在加上timebase，即0.01秒的周期数100000，把这个时间设置为下一次触发时钟的时间。也就是1秒触发100次。

接下来是：

    if (++ticks % TICK_NUM == 0) {
                print_ticks();
                print_num++;
            }
            if(print_num==10){
                sbi_shutdown();
            }
这段代码的作用就是当ticks（时钟中断的次数）每满100次，就触发一次print_ticks(),其定义如下：

    tatic void print_ticks() {
    cprintf("%d ticks\n", TICK_NUM);
    }
打印TICK_NUM，即100。

然后统计打印的次数，满十次就调用SBI的函数`sbi_shutdown()`关闭程序。

运行结果如下：

<p align="center">
  <img src="figure/zdm_fig2.png" alt="figure">
</p>

可以看见大约每1秒会输出一次”100 ticks”，输出10行，在打印完10行后调用sbi.h中的shut_down()函数关机。




### 扩展练习 Challenge1：描述与理解中断流程
回答：描述ucore中处理中断异常的流程（从异常的产生开始），其中mov a0，sp的目的是什么？SAVE_ALL中寄寄存器保存在栈中的位置是什么确定的？对于任何中断，__alltraps 中都需要保存所有寄存器吗？请说明理由。

### 扩增练习 Challenge2：理解上下文切换机制
回答：在trapentry.S中汇编代码 csrw sscratch, sp；csrrw s0, sscratch, x0实现了什么操作，目的是什么？save all里面保存了stval scause这些csr，而在restore all里面却不还原它们？那这样store的意义何在呢？

### 扩展练习Challenge3：完善异常中断
编程完善在触发一条非法指令异常 mret和，在 kern/trap/trap.c的异常处理函数中捕获，并对其进行处理，简单输出异常类型和异常指令触发地址，即“Illegal instruction caught at 0x(地址)”，“ebreak caught at 0x（地址）”与“Exception type:Illegal instruction"，“Exception type: breakpoint”。

## 列出你认为本实验中重要的知识点，以及与对应的OS原理中的知识点，并简要说明你对二者的含义，关系，差异等方面的理解（也可能出现实验中的知识点没有对应的原理知识点）

## 列出你认为OS原理中很重要，但在实验中没有对应上的知识点